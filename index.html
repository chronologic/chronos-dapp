<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta name="description" content="">
    <meta name="author" content="">
    <title>DAY token dApp</title>
    <!-- Latest compiled and minified CSS-->
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">
    <!-- Optional theme-->
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap-theme.min.css" integrity="sha384-rHyoN1iRsVXV4nD0JutlnGaslCJuC7uwjduW9SVrLvRYooPp2bWYgmgJQIXwl/Sp" crossorigin="anonymous">
  </head>
  <body>
    <nav class="navbar navbar-inverse navbar-fixed-top">
      <div class="container">
        <div class="navbar-header">
          <button type="button" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar" class="navbar-toggle collapsed"></button><a href="#" class="navbar-brand">Chronologic dApp</a><span id="accountInUse" style="margin:15px 15px; float:left; font-size:15px !important;" class="label label-light">Refresh to load Account</span>
        </div>
        <span id="deploy" style="margin:15px 15px; float:right; font-size:15px !important;" onclick="deployToken()" class="label label-success">Deploy</span>
        <span id="watch" style="margin:15px 15px; float:right; font-size:15px !important;" onclick="watchToken()" class="label label-success">Watch</span>
      </div>
    </nav>
    <div style="margin-top:80px;" class="container">
      <div id="meta-mask-required" class="panel-body"></div>
      <div class="page-header">
          <h1>Chronologic <small>day token dapp</small></h1>
          <h4>Follow the steps to deploy your own version of day token</h4>
      </div>
      <div class="panel panel-default">
          <!-- Default panel contents -->
          <div class="panel-body">
            <p><b>Step 1 : </b>Install MetaMask's chrome plugin, if you haven't already.</p>
            <p><b>Step 2 : </b>Approve 100 DAY Tokens as fees. Don't worry, they will only be deducted once your token is deployed</p>
            <p><b>Step 3 : </b>Tell us about the parameters you want for your token, and hit Deploy</p>
            <p><b>Step 4 : </b>100 DAY tokens will be deducted from your account, once the contract has been deployed</p>
            <p><b>Step 5 : </b>Accept the ownership of your token contract in the watch section</p>
            <p><b>Step 6 : </b>Use your tokens, however you want. You can even start allocating them.</p>
            <button type="button" class="btn btn-success" onClick="proceed()" style="float:right;">Proceed</button>
          </div>          
        </div>
       
        <div class="page-header">
            <h1>Transaction <small>history</small></h1>
        </div>
        <div class="panel panel-default">
            <!-- Default panel contents -->
            <div class="panel-body" id="historyStack">
              <p><b>Allowance</b></p><p><a href="https://ropsten.etherscan.io/tx/0x72e0492019d5868e499577c31e0ee89de4956be4d7338b3ce628a2fe4f396884">0x0B482E31ff16143719414Afa1EF102C6B39178F4</a></p>
              <hr>
              <p><b>Deployed</b></p><p><a href="https://ropsten.etherscan.io/tx/0x72e0492019d5868e499577c31e0ee89de4956be4d7338b3ce628a2fe4f396884">0x0B482E31ff16143719414Afa1EF102C6B39178F4</a></p>
              
            </div>          
          </div>  
    </div>
    <!-- /.container-->
    <!-- Bootstrap core JavaScript-->
    <script src="https://code.jquery.com/jquery-3.2.1.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
    <script src="https://cdn.rawgit.com/ethereum/web3.js/develop/dist/web3.js"></script>
    <script src="https://code.jquery.com/jquery-3.1.1.min.js"></script>
    <!-- Latest compiled and minified JavaScript-->
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>
    <script src="https://unpkg.com/sweetalert/dist/sweetalert.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/bluebird/3.5.1/bluebird.min.js"></script>
    <script type="text/javascript" src="dayTokenABI.js"></script>
    
    <script>
      // MetaMask injects the web3 library for us.
      var accounts;
      var tokenInstance, deployerInstance;
      var deployerAddress = "0x0B482E31ff16143719414Afa1EF102C6B39178F4"
      var minFee = "100000000000000000000"
   
      window.onload = function() {

        loadHistory();
       
        var a = jQuery.Deferred(),
        b=a.promise();
        //You can chain jQuery promises using .then
        b.then(connectWeb3)
        .then(loadAccounts)
        .then(getDayTokenInstance);
        a.resolve();
      }

      function proceed(){
        var x = jQuery.Deferred(),
        y=x.promise();
        y.then(checkAllowance)
        .then(function (result){
          if(result.valueOf()<minFee){
            swal({
                  title: "DAY Tokens needed",
                  text: "Please allow us to reserve 100 day tokens as fee",
                  icon: "info",
                  closeOnClickOutside: false,
                  buttons: true
                }).then(confirm => {
                    if(confirm)
                        var txHash = tokenInstance.approve(deployerAddress,minFee, function(error, result){
                            if(!error){
                                swal({
                                    title: "Token Release Tx Status",
                                    text: 'TxHash '+result
                                });
                                setTimeout(function(){ deployToken(); }, 3000);
                            }
                            else
                                swal({
                                    title: "Could not complete transaction",
                                    type:"error"
                                });
                        });
                });
          }
          else {
             deployToken();
            }
        });
        x.resolve();
      }
      function checkAllowance(){
        console.log("checking allowance")
        return new Promise(function(resolve,result){
              tokenInstance.allowance.call(accounts[0],deployerAddress,function(error, result) {
                  if (error) {
                      reject(error);
                  }
                   else {
                       resolve(result);}
              });
          });
      }
      function getDayTokenInstance(){
        tokenInstance = window.web3.eth.contract(dayTokenABI).at("0x7941bc77E1d6BD4628467b6cD3650F20F745dB06");
      }
      
      function watchToken(){
        swal({
          text: 'Network Address',
          content: "input",
          button: {
            text: "Watch!",
            closeModal: false,
          },
        })
        .then(name => {
          if (!name) throw null;
          window.location.replace("watchToken.html?tad="+name);
        })
      };

      function deployToken(){
        console.log("redirecting..")
        window.location.replace("deploy.html");
      };
      
      function connectWeb3(){
        if (typeof web3 === 'undefined') {
          document.getElementById('meta-mask-required').innerHTML = '<b>You need <a href="https://metamask.io/">MetaMask</a> browser plugin to run this contract</b>'
          window.web3 = new Web3(new Web3.providers.HttpProvider("http://localhost:8545"));
          }
        else
          window.web3 = new Web3(web3.currentProvider);
          window.web3.version.getNetwork((err, netId) => {
            console.log("netiD");
            switch (netId) {
              case "1":
                swal({
                  title: "Web3 Connected",
                  text: "You are connected to Mainnet.",
                  icon: "warning"
                });
                break
              case "2":
                swal({
                  title: "Web3 Connected",
                  text: "You are connected to deprecated network. Switch to Mainnet.",
                  icon: "warning"
                });
                break
              case "3":
                swal({
                  title: "Web3 Connected",
                  text: "You are connected to Testnet. Switch to Mainnet.",
                  icon: "warning"
                });
                break
              default:
                swal({
                  title: "Web3 Connected",
                  text: "You are connected to an unknown network",
                  icon: "warning"
                });
            }
        })
      }
      function getAccountBalance(tokenInstance, accountAddress) {
          return new Promise(function(resolve, reject) {
              tokenInstance.balanceOf(accountAddress, function(error, result) {
                  if (error) {
                      reject(error);
                  } else {
                      resolve(result);
                  }
              });
          })
      }
      function loadAccounts(){
        console.log("loading Accounts");
        accounts = web3.eth.accounts;
        console.log(accounts);
        $("#accountInUse").html("Account "+accounts);
      }
      
      function awaitBlockConsensus(web3s, txhash, blockCount, timeout) {
            var txWeb3 = web3s;
            var startBlock = Number.MAX_SAFE_INTEGER;
            var interval;
            var stateEnum = { start: 1, mined: 2, awaited: 3, confirmed: 4, unconfirmed: 5 };
            var savedTxInfo;
            var attempts = 0;
            console.log("txHash is",txhash)
            var pollState = stateEnum.start;
            var resolver, rejecter;
            var promise = new Promise(function(resolve, reject) {
                resolver = resolve;
                rejecter = reject;
            });
            var poll = function() {
                if (pollState === stateEnum.start) {
                    txWeb3.eth.getTransaction(txhash, function(e, txInfo) {
                        if (e || txInfo == null) {
                            console.log("Returning at", pollState);
                            return; // XXX silently drop errors
                        }
                        if (txInfo.blockHash != null) {
                            startBlock = txInfo.blockNumber;
                            savedTxInfo = txInfo;
                            console.log("pollState: mined");
                            pollState = stateEnum.mined;
                        }
                    });
                } else if (pollState == stateEnum.mined) {
                    txWeb3.eth.getBlockNumber(function(e, blockNum) {
                        if (e) {
                            console.log("Returning at", pollState);
                            return; // XXX silently drop errors
                        }
                        console.log("blockNum: ", blockNum);
                        if (blockNum >= (blockCount + startBlock)) {
                            console.log("pollState: awaited");
                            pollState = stateEnum.awaited;
                        }
                    });
                } else if (pollState == stateEnum.awaited) {
                    txWeb3.eth.getTransactionReceipt(txhash, function(e, receipt) {
                        if (e || receipt == null) {
                            console.log("Returning at", pollState);
                            return; // XXX silently drop errors.  TBD callback error?
                        }
                        // confirm we didn't run out of gas
                        // XXX this is where we should be checking a plurality of nodes.  TBD
                        clearInterval(interval);
                        if (receipt.gasUsed >= savedTxInfo.gas) {
                            pollState = stateEnum.unconfirmed;
                            rejecter(new Error("we ran out of gas, not confirmed!"));
                        } else {
                            pollState = stateEnum.confirmed;
                            console.log("Success","We did not run out of gas");
                            resolver(receipt);
                        }
                    });
                } else {
                    rejecter(new Error("We should never get here, illegal state: " + pollState));
                }
                // note assuming poll interval is 1 second
                attempts++;
                if (attempts > timeout) {
                    clearInterval(interval);
                    pollState = stateEnum.unconfirmed;
                    rejecter(new Error("Timed out, not confirmed"));
                }
            };
            interval = setInterval(poll, 1000);
            poll();
            return promise;
        };
    </script>
  </body>
</html>
