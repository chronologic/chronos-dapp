<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta name="description" content="">
    <meta name="author" content="">
    <title>DAY token dApp</title>
    <!-- Bootstrap core CSS -->
    <link href="vendor/bootstrap/css/bootstrap.min.css" rel="stylesheet">
    <!-- Custom fonts for this template -->
    <link href="vendor/font-awesome/css/font-awesome.min.css" rel="stylesheet" type="text/css">
    <link href="https://fonts.googleapis.com/css?family=Montserrat:400,700" rel="stylesheet" type="text/css">
    <link href="https://fonts.googleapis.com/css?family=Lato:400,700,400italic,700italic" rel="stylesheet" type="text/css">

    <!-- Custom styles for this template -->
    <link href="css/freelancer.min.css" rel="stylesheet">
    
  </head>
  <body id="page-top">
    <!-- Navigation -->
    <nav class="navbar navbar-expand-lg navbar-light fixed-top" id="mainNav">
        <div class="container">
          <a class="navbar-brand js-scroll-trigger" href="#page-top">Day Token</a>
          <button class="navbar-toggler navbar-toggler-right" type="button" data-toggle="collapse" data-target="#navbarResponsive" aria-controls="navbarResponsive" aria-expanded="false" aria-label="Toggle navigation">
            Menu
            <i class="fa fa-bars"></i>
          </button>
          <div class="collapse navbar-collapse" id="navbarResponsive">
            <ul class="navbar-nav ml-auto">
              <li class="nav-item" id="deploy">
                <a class="nav-link js-scroll-trigger" href="#portfolio">Deploy</a>
              </li>
              <li class="nav-item" id="watch">
                <a class="nav-link js-scroll-trigger" onclick="watchToken()">Watch</a>
              </li>
            </ul>
          </div>
        </div>
      </nav>
  
      <!-- Header -->
      <header class="masthead">
        <div class="container">
          <div class="intro-text">
            <span class="name">Deploy your own Day Token</span>
            <hr class="star-light">
            <div id="meta-mask-required" class="panel-body skills"></div>
          </div>
        </div>
      </header>
    <!-- <nav class="navbar navbar-inverse navbar-fixed-top">
      <div class="container">
        <div class="navbar-header">
          <button type="button" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar" class="navbar-toggle collapsed"></button><a href="#" class="navbar-brand">Chronologic dApp </a><span id="accountInUse" style="margin:15px 15px; float:left; font-size:15px !important;" class="label label-light">Refresh to load Account</span>
        </div><span id="watch" style="margin:15px 15px; float:right; font-size:15px !important;" onclick="watchToken()" class="label label-success">Watch a Token</span>
      </div>
    </nav>
    <div style="margin-top:80px;" class="container">
      <div id="meta-mask-required" class="panel-body"></div>
      <div></div>
    </div> -->
    <!-- /.container-->
    <!-- Bootstrap core JavaScript-->
    <script src="https://code.jquery.com/jquery-3.2.1.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
    <script src="https://cdn.rawgit.com/ethereum/web3.js/develop/dist/web3.js"></script>
    <script src="https://code.jquery.com/jquery-3.1.1.min.js"></script>
    <!-- Latest compiled and minified JavaScript-->
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>
    <script src="https://unpkg.com/sweetalert/dist/sweetalert.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/bluebird/3.5.1/bluebird.min.js"></script>
    <script type="text/javascript" src="dayTokenABI.js"></script>
    
    <script>
      // MetaMask injects the web3 library for us.
      var accounts;
      var tokenInstance, deployerInstance;
      var deployerAddress = "0x0B482E31ff16143719414Afa1EF102C6B39178F4"
      var minFee = "100000000000000000000"
   
      window.onload = function() {
       
        var a = jQuery.Deferred(),
        b=a.promise();
        //You can chain jQuery promises using .then
        b.then(connectWeb3)
        .then(loadAccounts)
        .then(getDayTokenInstance)
        .then(checkAllowance)
        .then(function (result){
          if(result.valueOf()<minFee){
            swal({
                  title: "Allowance needed",
                  text: "Please allow us to take 100 day tokens as fee",
                  icon: "info",
                  buttons: true
                }).then(confirm => {
                    if(confirm)
                        var txHash = tokenInstance.approve(deployerAddress,minFee, function(error, result){
                            if(!error){
                                txUrl = baseNetworkURL+"tx/"+result;
                                swal({
                                    title: "Token Release Tx Status",
                                    text: 'TxHash '+result
                                });
                            }
                            else
                                swal({
                                    title: "Could not complete transaction",
                                    type:"error"
                                });
                        });
                });
          }
        });
        a.resolve();
      }
      function checkAllowance(){
        console.log("checking allowance")
        return new Promise(function(resolve,result){
              tokenInstance.allowance.call(accounts[0],deployerAddress,function(error, result) {
                  if (error) {
                      reject(error);
                  }
                   else {
                       resolve(result);}
              });
          });
      }
      function getDayTokenInstance(){
        tokenInstance = window.web3.eth.contract(dayTokenABI).at("0x7941bc77E1d6BD4628467b6cD3650F20F745dB06");
      }

      function watchToken(){
        swal({
          text: 'Network Address',
          content: "input",
          button: {
            text: "Watch!",
            closeModal: false,
          },
        })
        .then(name => {
          if (!name) throw null;
          window.location.replace("watchToken.html?tad="+name);
        })
      };
      
      function connectWeb3(){
        if (typeof web3 === 'undefined') {
          document.getElementById('meta-mask-required').innerHTML = '<b>You need <a href="https://metamask.io/">MetaMask</a> browser plugin to run this contract</b>'
          window.web3 = new Web3(new Web3.providers.HttpProvider("http://localhost:8545"));
          }
        else
          window.web3 = new Web3(web3.currentProvider);
          window.web3.version.getNetwork((err, netId) => {
            console.log("netiD");
            switch (netId) {
              case "1":
                swal({
                  title: "Web3 Connected",
                  text: "You are connected to Mainnet.",
                  icon: "warning"
                });
                break
              case "2":
                swal({
                  title: "Web3 Connected",
                  text: "You are connected to deprecated network. Switch to Mainnet.",
                  icon: "warning"
                });
                break
              case "3":
                swal({
                  title: "Web3 Connected",
                  text: "You are connected to Testnet. Switch to Mainnet.",
                  icon: "warning"
                });
                break
              default:
                swal({
                  title: "Web3 Connected",
                  text: "You are connected to an unknown network",
                  icon: "warning"
                });
            }
        })
      }
      function getAccountBalance(tokenInstance, accountAddress) {
          return new Promise(function(resolve, reject) {
              tokenInstance.balanceOf(accountAddress, function(error, result) {
                  if (error) {
                      reject(error);
                  } else {
                      resolve(result);
                  }
              });
          })
      }
      function loadAccounts(){
        console.log("loading Accounts");
        accounts = web3.eth.accounts;
        console.log(accounts);
        $("#accountInUse").html("Account "+accounts);
      }
      function awaitBlockConsensus(web3s, txhash, blockCount, timeout) {
            var txWeb3 = web3s;
            var startBlock = Number.MAX_SAFE_INTEGER;
            var interval;
            var stateEnum = { start: 1, mined: 2, awaited: 3, confirmed: 4, unconfirmed: 5 };
            var savedTxInfo;
            var attempts = 0;
            console.log("txHash is",txhash)
            var pollState = stateEnum.start;
            var resolver, rejecter;
            var promise = new Promise(function(resolve, reject) {
                resolver = resolve;
                rejecter = reject;
            });
            var poll = function() {
                if (pollState === stateEnum.start) {
                    txWeb3.eth.getTransaction(txhash, function(e, txInfo) {
                        if (e || txInfo == null) {
                            console.log("Returning at", pollState);
                            return; // XXX silently drop errors
                        }
                        if (txInfo.blockHash != null) {
                            startBlock = txInfo.blockNumber;
                            savedTxInfo = txInfo;
                            console.log("pollState: mined");
                            pollState = stateEnum.mined;
                        }
                    });
                } else if (pollState == stateEnum.mined) {
                    txWeb3.eth.getBlockNumber(function(e, blockNum) {
                        if (e) {
                            console.log("Returning at", pollState);
                            return; // XXX silently drop errors
                        }
                        console.log("blockNum: ", blockNum);
                        if (blockNum >= (blockCount + startBlock)) {
                            console.log("pollState: awaited");
                            pollState = stateEnum.awaited;
                        }
                    });
                } else if (pollState == stateEnum.awaited) {
                    txWeb3.eth.getTransactionReceipt(txhash, function(e, receipt) {
                        if (e || receipt == null) {
                            console.log("Returning at", pollState);
                            return; // XXX silently drop errors.  TBD callback error?
                        }
                        // confirm we didn't run out of gas
                        // XXX this is where we should be checking a plurality of nodes.  TBD
                        clearInterval(interval);
                        if (receipt.gasUsed >= savedTxInfo.gas) {
                            pollState = stateEnum.unconfirmed;
                            rejecter(new Error("we ran out of gas, not confirmed!"));
                        } else {
                            pollState = stateEnum.confirmed;
                            resolver(receipt);
                        }
                    });
                } else {
                    rejecter(new Error("We should never get here, illegal state: " + pollState));
                }
                // note assuming poll interval is 1 second
                attempts++;
                if (attempts > timeout) {
                    clearInterval(interval);
                    pollState = stateEnum.unconfirmed;
                    rejecter(new Error("Timed out, not confirmed"));
                }
            };
            interval = setInterval(poll, 1000);
            poll();
            return promise;
        };
    </script>
  </body>
</html>

