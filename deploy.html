<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta name="description" content="">
    <meta name="author" content="">
    <title>DAY token dApp</title>
    <!-- Latest compiled and minified CSS-->
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">
    <!-- Optional theme-->
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap-theme.min.css" integrity="sha384-rHyoN1iRsVXV4nD0JutlnGaslCJuC7uwjduW9SVrLvRYooPp2bWYgmgJQIXwl/Sp" crossorigin="anonymous">
  </head>
  <body>
    <nav class="navbar navbar-inverse navbar-fixed-top">
      <div class="container">
        <div class="navbar-header">
          <button type="button" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar" class="navbar-toggle collapsed"></button><a href="#" class="navbar-brand">Chronologic dApp </a><span id="accountInUse" style="margin:15px 15px; float:left; font-size:15px !important;" class="label label-light">Refresh to load Account</span>
        </div><span id="watch" style="margin:15px 15px; float:right; font-size:15px !important;" onclick="watchToken()" class="label label-success">Watch a Token</span>
      </div>
    </nav>
    <div style="margin-top:80px;" class="container">
      <div id="meta-mask-required" class="panel-body"></div>
      <form>
        <div class="col-lg-6 col-md-6 col-sm-12">
          <div class="form-group">
            <label for="name">Name</label>
            <input id="name" type="text" class="form-control">
          </div>
          <div class="form-group">
            <label for="symbol">Symbol</label>
            <input id="symbol" type="text" class="form-control">
          </div>
          <div class="form-group">
            <label for="maxAddresses">Max Addresses</label>
            <input id="maxAddresses" type="text" class="form-control">
          </div>
          <div class="form-group">
            <label for="firstTeamContributionId">First team Contriutiors Id</label>
            <input id="firstTeamContributionId" type="text" class="form-control">
          </div>
          <div class="form-group">
            <label for="totalTeamContributionId">Total team Contriutiors Id</label>
            <input id="totalTeamContributionId" type="text" class="form-control">
          </div>
          <div class="form-group">
            <label for="totalPostIcoContributorIds">Total Post ICO Contriutiors Id</label>
            <input id="totalPostIcoContributorIds" type="text" class="form-control">
          </div>
        </div>
        <div class="col-lg-6 col-md-6 col-sm-12">
          <div class="form-group">
            <label for="minMintingPower">Minimum Minting Power</label>
            <input id="minMintingPower" type="text" class="form-control">
          </div>
          <div class="form-group">
            <label for="maxMintingPower">Max Minting Power</label>
            <input id="maxMintingPower" type="text" class="form-control">
          </div>
          <div class="form-group">
            <label for="halvingCycle">Halving Cycle</label>
            <input id="halvingCycle" type="text" class="form-control">
          </div>
          <div class="form-group">
            <label for="teamLockPeriodInSec">Team Lock Period In Sec</label>
            <input id="teamLockPeriodInSec" type="text" class="form-control">
          </div>
          <div class="form-group">
            <label for="minBalanceToSell">Minimum Balance To Sell</label>
            <input id="minBalanceToSell" type="text" class="form-control">
          </div>
        </div>
      </form>
      <div class="col-md-2 col-md-offset-5">            
        <button type="button" style="margin: 5px;" onclick="send()" class="btn btn-success col-md-12"> Submit</button>
      </div>
    </div>
    <!-- /.container-->
    <!-- Bootstrap core JavaScript-->
    <script src="https://code.jquery.com/jquery-3.2.1.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
    <script src="https://cdn.rawgit.com/ethereum/web3.js/develop/dist/web3.js"></script>
    <script src="https://code.jquery.com/jquery-3.1.1.min.js"></script>
    <!-- Latest compiled and minified JavaScript-->
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>
    <script src="https://unpkg.com/sweetalert/dist/sweetalert.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/bluebird/3.5.1/bluebird.min.js"></script>
    <script type="text/javascript"  src="DeployNewTokenABI.js"></script>
    <script type="text/javascript" src="dayTokenABI.js"></script>
    
    <script>
      // MetaMask injects the web3 library for us.
      var accounts;
      var tokenInstance, deployerInstance;
      var deployerAddress = "0x0B482E31ff16143719414Afa1EF102C6B39178F4"
      var minFee = "100000000000000000000"
   
      window.onload = function() {
       
        var a = jQuery.Deferred(),
        b=a.promise();
        //You can chain jQuery promises using .then
        b.then(connectWeb3)
        .then(loadAccounts)
        .then(getDayTokenInstance)
        .then(checkAllowance)
        .then(function (result){
          if(result.valueOf()<minFee){
            swal({
                  title: "DAY Tokens needed",
                  text: "Please allow us to reserve 100 day tokens as fee",
                  icon: "info",
                  closeOnClickOutside: false,
                  buttons: true
                }).then(confirm => {
                    if(confirm)
                        var txHash = tokenInstance.approve(deployerAddress,minFee, function(error, result){
                            if(!error){
                                txUrl = baseNetworkURL+"tx/"+result;
                                setStorage("Release",result);
                                swal({
                                    title: "Token Release Tx Status",
                                    text: 'TxHash '+result
                                });
                            }
                            else
                                swal({
                                    title: "Could not complete transaction",
                                    type:"error"
                                });
                        });
                });
          }
        });
        a.resolve();
      }
      function checkAllowance(){
        console.log("checking allowance")
        return new Promise(function(resolve,result){
              tokenInstance.allowance.call(accounts[0],deployerAddress,function(error, result) {
                  if (error) {
                      reject(error);
                  }
                   else {
                       resolve(result);}
              });
          });
      }
      function getDayTokenInstance(){
        tokenInstance = window.web3.eth.contract(dayTokenABI).at("0x7941bc77E1d6BD4628467b6cD3650F20F745dB06");
      }
      function getDeployerInstance(){
        return new Promise(function(resolve,result){
               window.web3.eth.contract(deployerABI).at(deployerAddress,function(error, result) {
                  if (error) {
                      reject(error);
                  }
                   else {
                       resolve(result);}
              });
          });
      }
      function transact() {
            getDeployerInstance().then(function(deployerInstance) {
                console.log("deploying new token");
                var _tokenName = $("#name").val();
                var _tokenSymbol = $("#symbol").val();
                var _maxAddresses = $("#maxAddresses").val();
                var _firstTeamContributorId = $("#firstTeamContributionId").val();
                var _totalTeamContributorIds = $("#totalTeamContributionId").val();
                var _totalPostIcoContributorIds = $("#totalPostIcoContributorIds").val();
                var _minMintingPower = $("#minMintingPower").val();
                var _maxMintingPower = $("#maxMintingPower").val();
                var _halvingCycle = $("#halvingCycle").val();
                var _DayInSecs = '84600';
                var _minBalanceToSell = $("#teamLockPeriodInSec").val();
                var _teamLockPeriodInSec = $("#minBalanceToSell").val();
                //- var _tokenName = "Day";
                //- var _tokenSymbol = "DAY";
                //- var _tokenDecimals = 18;
                //- var _tokenInitialSupply = 0;
                //- var _tokenMintable = true;
                //- var _maxAddresses = 7;
                //- var _firstTeamContributorId = 4;
                //- var _totalTeamContributorIds = 2;
                //- var _totalPostIcoContributorIds = 2;
                //- var _minMintingPower = 500000000000000000;
                //- var _maxMintingPower = 1000000000000000000;
                //- var _halvingCycle = 88;
                //- var _DayInSecs = 84600;
                //- var _minBalanceToSell = 8888;
                //- var _teamLockPeriodInSec = 15780000;
                var txHash = deployerInstance.createCustomDayToken(_tokenName,_tokenSymbol,_maxAddresses,_firstTeamContributorId,_totalTeamContributorIds,_totalPostIcoContributorIds,_minMintingPower,_maxMintingPower,_halvingCycle,_minBalanceToSell,_DayInSecs, _teamLockPeriodInSec, function(error, result){
                      if(result)
                      setStorage("Deployed",result);
                        swal({
                          title: "Transaction sent for mining",
                          text: "Tx Hash : "+result,
                          icon: "info",
                          buttons: true
                        })
                        return awaitBlockConsensus(window.web3, result,2, 200);
                  });
                return awaitBlockConsensus(web3, txHash, 2, 200);
            }, function(error) {
                console.log('Could not fetch deployer', error);
                return Promise.reject(error);
            }).then(function(result) {
              console.log("transaction mined at",result);
            }, function(error) {
                console.log("there was some error",error);
            });
        }
      function send(){
        var d = jQuery.Deferred(),
        p=d.promise();
        //You can chain jQuery promises using .then
        p.then(transact);
        d.resolve();
      }
      function deployNewToken(){
          console.log("deploying new token");
          //- var _tokenName = $("#name").val();
          //- var _tokenSymbol = $("#symbol").val();
          //- var _maxAddresses = $("#maxAddresses").val();
          //- var _firstTeamContributorId = $("#firstTeamContributionId").val();
          //- var _totalTeamContributorIds = $("#totalTeamContributionId").val();
          //- var _totalPostIcoContributorIds = $("#totalPostIcoContributorIds").val();
          //- var _minMintingPower = $("#minMintingPower").val();
          //- var _maxMintingPower = $("#maxMintingPower").val();
          //- var _halvingCycle = $("#halvingCycle").val();
          //- var _DayInSecs = '84600';
          //- var _minBalanceToSell = $("#teamLockPeriodInSec").val();
          //- var _teamLockPeriodInSec = $("#minBalanceToSell").val();
          var _tokenName = "Day";
          var _tokenSymbol = "DAY";
          var _tokenDecimals = 18;
          var _tokenInitialSupply = 0;
          var _tokenMintable = true;
          var _maxAddresses = 7;
          var _firstTeamContributorId = 4;
          var _totalTeamContributorIds = 2;
          var _totalPostIcoContributorIds = 2;
          var _minMintingPower = 500000000000000000;
          var _maxMintingPower = 1000000000000000000;
          var _halvingCycle = 88;
          var _DayInSecs = 84600;
          var _minBalanceToSell = 8888;
          var _teamLockPeriodInSec = 15780000;
          var txHash = deployerInstance.createCustomDayToken(_tokenName,_tokenSymbol,_maxAddresses,_firstTeamContributorId,_totalTeamContributorIds,_totalPostIcoContributorIds,_minMintingPower,_maxMintingPower,_halvingCycle,_minBalanceToSell,_DayInSecs, _teamLockPeriodInSec, function(error, result){
                if(result)
                setStorage("Deployed",result);
                  return awaitBlockConsensus(window.web3, result,"2", "200");
            });
      }
      function watchToken(){
        swal({
          text: 'Network Address',
          content: "input",
          button: {
            text: "Watch!",
            closeModal: false,
          },
        })
        .then(name => {
          if (!name) throw null;
          window.location.replace("watchToken.html?tad="+name);
        })
      };
      function connectWeb3(){
        if (typeof web3 === 'undefined') {
          document.getElementById('meta-mask-required').innerHTML = '<b>You need <a href="https://metamask.io/">MetaMask</a> browser plugin to run this contract</b>'
          window.web3 = new Web3(new Web3.providers.HttpProvider("http://localhost:8545"));
          }
        else
          window.web3 = new Web3(web3.currentProvider);
          window.web3.version.getNetwork((err, netId) => {
            console.log("netiD");
            switch (netId) {
              case "1":
                swal({
                  title: "Web3 Connected",
                  text: "You are connected to Mainnet.",
                  icon: "warning"
                });
                break
              case "2":
                swal({
                  title: "Web3 Connected",
                  text: "You are connected to deprecated network. Switch to Mainnet.",
                  icon: "warning"
                });
                break
              case "3":
                swal({
                  title: "Web3 Connected",
                  text: "You are connected to Testnet. Switch to Mainnet.",
                  icon: "warning"
                });
                break
              default:
                swal({
                  title: "Web3 Connected",
                  text: "You are connected to an unknown network",
                  icon: "warning"
                });
            }
        })
      }
      function getAccountBalance(tokenInstance, accountAddress) {
          return new Promise(function(resolve, reject) {
              tokenInstance.balanceOf(accountAddress, function(error, result) {
                  if (error) {
                      reject(error);
                  } else {
                      resolve(result);
                  }
              });
          })
      }
      function loadAccounts(){
        console.log("loading Accounts");
        accounts = web3.eth.accounts;
        console.log(accounts);
        $("#accountInUse").html("Account "+accounts);
      }
      function awaitBlockConsensus(web3s, txhash, blockCount, timeout) {
            var txWeb3 = web3s;
            var startBlock = Number.MAX_SAFE_INTEGER;
            var interval;
            var stateEnum = { start: 1, mined: 2, awaited: 3, confirmed: 4, unconfirmed: 5 };
            var savedTxInfo;
            var attempts = 0;
            console.log("txHash is",txhash)
            var pollState = stateEnum.start;
            var resolver, rejecter;
            var promise = new Promise(function(resolve, reject) {
                resolver = resolve;
                rejecter = reject;
            });
            var poll = function() {
                if (pollState === stateEnum.start) {
                    txWeb3.eth.getTransaction(txhash, function(e, txInfo) {
                        if (e || txInfo == null) {
                            console.log("Returning at", pollState);
                            return; // XXX silently drop errors
                        }
                        if (txInfo.blockHash != null) {
                            startBlock = txInfo.blockNumber;
                            savedTxInfo = txInfo;
                            console.log("pollState: mined");
                            pollState = stateEnum.mined;
                        }
                    });
                } else if (pollState == stateEnum.mined) {
                    txWeb3.eth.getBlockNumber(function(e, blockNum) {
                        if (e) {
                            console.log("Returning at", pollState);
                            return; // XXX silently drop errors
                        }
                        console.log("blockNum: ", blockNum);
                        if (blockNum >= (blockCount + startBlock)) {
                            console.log("pollState: awaited");
                            pollState = stateEnum.awaited;
                        }
                    });
                } else if (pollState == stateEnum.awaited) {
                    txWeb3.eth.getTransactionReceipt(txhash, function(e, receipt) {
                        if (e || receipt == null) {
                            console.log("Returning at", pollState);
                            return; // XXX silently drop errors.  TBD callback error?
                        }
                        // confirm we didn't run out of gas
                        // XXX this is where we should be checking a plurality of nodes.  TBD
                        clearInterval(interval);
                        if (receipt.gasUsed >= savedTxInfo.gas) {
                            pollState = stateEnum.unconfirmed;
                            rejecter(new Error("we ran out of gas, not confirmed!"));
                        } else {
                            pollState = stateEnum.confirmed;
                            resolver(receipt);
                        }
                    });
                } else {
                    rejecter(new Error("We should never get here, illegal state: " + pollState));
                }
                // note assuming poll interval is 1 second
                attempts++;
                if (attempts > timeout) {
                    clearInterval(interval);
                    pollState = stateEnum.unconfirmed;
                    rejecter(new Error("Timed out, not confirmed"));
                }
            };
            interval = setInterval(poll, 1000);
            poll();
            return promise;
        };
        function setStorage(key,value){
          if (typeof(Storage) !== "undefined") {
            sessionStorage.setItem(key, value);
          } else {
            console.log("Could not store transaction details")
          }
        }

        function getStorage(){
          if (typeof(Storage) !== "undefined") {
            for (i = 0; i < sessionStorage.length; i++) {
                console.log(sessionStorage.key(i) + "=[" + sessionStorage.getItem(sessionStorage.key(i)) + "]");
            }
          } else {
            console.log("Could not get transaction details")
          }
        }
    </script>
  </body>
</html>
